#+TITLE: Logitech Keyboard Configuration
#+HTML_HEAD: <style>pre.src{font-family: Fira Code, JetBrains Mono, Hack, monospace;}</style>

To allow for easier configuration, I am using "variables" for parts of the config that are subject to change between different setups.
These "variables" are implemented using Org mode's [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb]] syntax, which allows for code blocks to insert the contents of other code blocks.

Because the default reference syntax: ~<<BLOCK_NAME>>~, is valid syntax in some languages, I changed the syntax to ~|>BLOCK_NAME<|~.
When the document is tangled, these ~|>BLOCK_NAME<|~ references are replaced with the contents of the corresponding named variable block in [[Global Variables]] or elsewhere.
Variable names are all uppercase, and their definitions will mirror the structure shown in [[Global Variables]].

* Global Variables
- ~KEYBOARD~ ::
 #+NAME: KEYBOARD
 #+begin_src text
/dev/input/by-id/usb-Logitech_USB_Receiver-if02-event-kbd
 #+end_src
- ~STARSHIP_RUNNER_CONFIG~ ::
  I want the runner to have a different configuration than my normal shell, so this points to the other config
  #+NAME: STARSHIP_RUNNER_CONFIG
  #+begin_src text
~/.config/starship_runner.toml
  #+end_src
** Program Paths
- ~ST~ ::
 #+NAME: ST
 #+begin_src text
~/.local/bin/st
 #+end_src
- ~ROFI~ ::
 #+NAME: ROFI
 #+begin_src text
/usr/bin/rofi
 #+end_src
- ~EMACSCLIENT~ ::
  #+NAME: EMACSCLIENT
  #+begin_src text
/usr/bin/emacsclient
  #+end_src
- ~DISCORD~ ::
  #+NAME: DISCORD
  #+begin_src text
/usr/bin/Discord
  #+end_src
- ~BROTAB~ ::
  #+NAME: BROTAB
  #+begin_src text
~/.local/bin/brotab
  #+end_src
* Super Keybindings
I want to be able to use Super like a leader key when tapped.
Each headline represents a key to be pressed after tapping Super.
** Q :: Window Switcher
Launches the window switcher.
** D :: Discord
Opens Discord.
** E :: Emacs
Opens Emacs
** F :: Firefox
Opens Firefox
** B :: Brightness
Opens ~BrightnessControl~ GUI *OR* initiates ~BrightnessControl~ layer, where we can manipulate brightness with ~hjkl~.
Also look into [[https://github.com/maoserr/redshiftgui][redshiftgui]] to see if we can use this instead. I left it alone because building it requires a library that isn't in the Fedora repos called "[[https://sourceforge.net/projects/iup/files/3.30/Linux%20Libraries/][IUP]]".
*** BrightnessControl Layer
**** TODO H
Rotate active monitor to the left.
**** TODO L
Rotate active monitor to the right.
**** K
Brightness Up.
**** J
Brightness Down.
**** 0-9
Used to change brightness by a percentage; typing ~5k~ will raise the brightness by 5.
**** Tab
Switches focus per the base leader behavior.
**** Esc | Super
Exit layer.
** T :: Terminal (Scratchpad)
Opens terminal scratchpad.
*** Hold
Opens menu with all of the available scratchpads.
*** Tap
+Opens most recently opened scratchpad+.
We can use ~yakuake~ for this basic functionality.
Instead, dedicate this to the *Terminal Layer*?.
*** Terminal Layer
**** +Super,+​] :: Next
Next terminal scratchpad (cycle).
**** +Super,+​[ :: Previous
Last terminal scratchpad (cycle).
**** L :: List
Show all open scratchpads and prompt for which one to open.
**** V :: Vim
Create a Vim scratchpad that will be deleted immediately after Vim closes.
** R :: Run
Run a single command in a small popup window.

Have it appear at the top of the screen, and have the window expand down as the output fills.

This could be super useful for things like ~remind-in 10m Do something~.
*** Layer
**** Super, Esc (in sequence)
Exit layer and close ~run~ window.
**** E
Make window taller.
*** Notes
**** Keybindings
In the spawned window, bind Ctrl+R to resize the window to the necessary length, Esc/Enter to revert the size.

After you press enter "for real", hand the scrollback buffer to ~pee resizing_program.sh less~
Might have to use kitty for this.
**** Window Properties
Source: https://www.reddit.com/r/kde/comments/d5ne9s/can_you_have_no_titlebar_and_frame_but_keep_the/
Made a window-specific override for the window class "st-runner" that disabled the title bar.
This lets us havae the nice shadow but without the title bar.
** P :: Prompt
Opens prompt to open ~rofi~ and launch custom actions by typing.
*** thyme
Opens ~rofi~ with list of ~thyme~ files.
Choose a date and then view the breakdown for that date.
*** incognito
Turns on VPN.
Disables ~thyme~.

If called a second time, disables both of these.
** A :: Agenda
Opens agenda.
** O :: Open Preset
*** Tap
Gives you preset-local shortcuts.

Automatically show help for it (this is hard to memorize).
Emacs ~which-key~ style help.
*** Hold
Opens ~rofi~ with list of available "presets".

If currently in a preset, exit the preset.
Currently loaded presets should be at the top!.
If you select a preset while another is currently active, disable the old preset.

Add support for virtual-desktop-local presets in the future.
*** Presets
**** leetcode
***** Left Monitor
1. Open fullscreen terminal.
2. ~cd ~/Development/leetcode/problems~.
***** Right Monitor
+1. Open firefox+.
+2. Navigate to [[https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU][New Year Gift - Curated List of Top 75 LeetCode Questions to Save Your Time]]+.
+3.+
0. Open firefox?.
   This would be so that when you press enter in emacs, it would open the link in the right firefox window.
1. Open ~emacs~.
2. Navigate to "problems.org".
3. Select a problem.
4. When you press enter, open the link in our firefox window and then close emacs.
***** Preset-Local Shortcuts
****** O :: Open Problem List
Opens the ~emacs~ window once again and loops from step #1.
** C :: Org-Capure
Opens org-capture.
I already have this bound to ~Super+C~, but having it on ~Super, C~ would make it easier to invoke.
** S :: Scroll
Layer that lets you emulate mouse wheel scrolling using vim keys
*** Scroll Layer
**** H
Scroll to the left
**** J
Scroll down
**** K
Scroll up
**** L
Scroll to the right
**** Shift
Increase scroll speed while held
**** Ctrl
Decrease scroll speed while held
** V :: Volume
Layer that allows you to easily change the volume using the keyboard
*** Volume Layer
**** H
Rotate current output left.
**** J
Rotate current output right.
**** K
Volume up by 5.
**** L
Volume down by 5.
**** M
Toggles the muteness (?) of the current output and exits the Volume Layer
**** Q
Toggles volume ~osd~ visibility.
*** DONE Figure out which library to use to create the volume applet
#+begin_quote
I did a bunch of research into GUI overlays on Linux that can render over fullscreen applications.
There is a significant lack of resources on the topic, but one thing I did get working was a demo using the [[https://github.com/davidmaamoaix/overlay][overlay]] Python library, which is built on ~tkinter~.
The downside is that ~overlay~ is unmaintained and doesn't work on Linux without [[https://github.com/davidmaamoaix/overlay/issues/2#issuecomment-650091963][changing the source]].
I have yet to see if what I am trying to accomplish is possible with this library, but it /can/ render over fullscreen, which is a good start.

I also looked into [[https://github.com/brndnmtthws/conky][conky]], assuming that it would be able to render over fullscreen applications, but it turns out it cannot.
#+end_quote

I ended up using KDE's ~osd~ with its DBus interface, emulating the normal volume popups that you get with the stock volume keys.
This has the benefit of fitting in with the system theme, and only took a single line to implement
** \ :: Local Leader Key
Use this in conjunction with presets to have local preset keybindings.
** Tab :: Switch Focus
When tapped, should switch the focus between monitors.
When held for more than a certain duration, should move the cursor over to the next monitor.
** Super :: Super
Acts as a regular press of Super (hands it to KDE).
* Configuration
#+PROPERTY: header-args :tangle yes :noweb tangle
#+begin_src kbdx
[configuration]
input = "|>KEYBOARD<|"

output-name = "Logitech KMonad Output"
output-pre-command = "/usr/bin/sleep 0.75 && /usr/bin/setxkbmap -option compose:rctrl"

cmp-seq = 'rctrl'
cmp-seq-delay = 5

fallthrough = true
allow-cmd = true

# indicate which layer you want to be in when KMonad launches
starting-layer = qwerty-homerow-mods
#+end_src
** Constants
#+begin_src kbdx
[aliases]
tap-hold-delay = 200
tap-hold-delay-min = 160

kwin_shortcut_cmd = "qdbus org.kde.kglobalaccel /component/kwin invokeShortcut"
#+end_src
* Default Layer
#+begin_quote
Optional: as many layers as you please

We had already defined `num` as referring to a `(layer-toggle numbers)`. We
will get into layer-manipulation soon, but first, let's just create a second
layer that overlays a numpad under our right-hand.

To easily specify layers it is highly recommended to create an empty
`deflayer` statement as a comment at the top of your config, so you can simply
copy-paste this template. There are also various empty layer templates
available in the './keymap/template' directory.
#+end_quote

Enable the "leader" layer for the next keypress.
If we release @leader_key /before/ the next key, we treat the keypress as a *tap*, even if for a short period of time both keys were down.
If we release @leader_key /after/ the next key, we treat it as holding.

Also, if we hold the key for more than 250 milliseconds, treat it like we are holding the key.
When we are trying to use the super key in a tap melody, we have the key down for a very short time, so having the hold timeout on 250ms lets us use it for chords more conveniently

#+begin_src kbdx
[base]
[[private]]
leader-key = (tap-hold-next-release 250 (around-next (layer-toggle leader)) lmet)
[[keys]]
lmet = leader-key
grave = (tap-hold $tap-hold-delay-min grave @simple-datetime-overlay) # (ref:simple-datetime-overlay)
lalt = (tap-hold-next-release $tap-hold-delay XX (around lalt (around-next (layer-toggle leader-no-block))))
#+end_src

#+begin_src kbdx
[qwerty]
parent = base
[[private]]
enable-homerow-mods = (layer-switch qwerty-homerow-mods)
[[keys]]
ScrollLock = enable-homerow-mods
caps = 'lctrl'
#+end_src

#+begin_src kbdx
[qwerty-homerow-mods]
parent = base
[[private]]
disable-homerow-mods = (layer-switch qwerty)
lctrl-or-escape = (tap-hold-next-release 125 esc lctl)
lshift-or-caps-lock = (tap-hold-next-release 125 caps lshift)
rshift-or-caps-lock = (tap-hold-next-release 125 caps rshift)
#+end_src

This is a ~GACS~ home-row-mods configuration detailed on [[https://precondition.github.io/home-row-mods#kmonad-home-row-mods-code-generator][this page]].
~k~ is bound to ~lctl~ rather than ~rctl~ because ~rctl~ is the compose key on my system.
#+begin_src kbdx
hmod-delay = $tap-hold-delay

a_homerow_chords = (tap-hold $hmod-delay a (layer-toggle home-row-chord))
q_homerow_movement = (tap-hold $hmod-delay q (layer-toggle home-row-movement))
backslash_desktop_window = (tap-hold-next-release $hmod-delay \ (layer-toggle desktop-window))
s_lalt = (tap-hold-next-release $hmod-delay s lalt)
d_lctrl = (tap-hold-next-release $hmod-delay d lctl)
f_lshift = (tap-hold-next-release $hmod-delay f lshift)

k_lctrl = (tap-hold-next-release $hmod-delay k lctl)
j_rshift = (tap-hold-next-release $hmod-delay j rshift)
l_ralt = (tap-hold-next-release $hmod-delay l ralt)
#+end_src

- TODO:
  Use ~caps~ key to enable key repeat on home row modifiers
- TODO:
  While holding caps, disable home row modifiers?
  Disable home-row modifiers while ~rshift~ or ~lshift~ are being held; basically any explicit modifier

#+begin_src kbdx
[[keys]]
ScrollLock = disable-homerow-mods
caps = lctrl-or-escape

a = a_homerow_chords
q = q_homerow_movement
backslash = backslash_desktop_window
s = s_lalt
d = d_lctrl
f = f_lshift
k = k_lctrl
j = j_rshift
l = l_ralt
#+end_src

We want to disable the homerow mods whenever we explicitly hit a modifier key.
#+begin_src kbdx
lshift = (around (layer-toggle qwerty) @lshift-or-caps-lock)
rshift = (around (layer-toggle qwerty) @rshift-or-caps-lock)
lctrl = (around (layer-toggle qwerty) lctrl)
#+end_src
* Base Leader Key Layer
#+begin_src kbdx
[leader]
parent = block
[[keys]]
q = window-switcher # (ref:window-switcher)
d = discord # (ref:discord)
e = emacs # (ref:emacs)
f = firefox_composite # (ref:firefox)
b = brightness:enter # (ref:brightness)
v = volume:enter # (ref:volume)
t = 't' # (ref:terminal)
r = run:enter # (ref:run)
p = 'p' # (ref:prompt)
a = agenda # (ref:agenda)
o = open-preset # (ref:open-preset)
c = org-capture # (ref:org-capture)
s = scroll:enter # (ref:scroll)
tab = switch_focus_composite # (ref:switch-focus)
f1 = vim # (ref:vim)
backslash = 'backslash' # (ref:local-leader)
lmet = 'lmet'

[leader-no-block]
parent = { source, leader }
#+end_src
* Home Row Chord Layer
#+begin_src kbdx
[home-row-chord]
parent = { block, numeric-desktop-switching }
[[private]]
show_desktop_grid = (cmd-button "$kwin_shortcut_cmd \"ShowDesktopGrid\"")
[[keys]]
# this binding interferes with rolls
# t = (around lshift 5)

# these are just the special characters above them
y = (around lshift 6)
u = (around lshift 7)
i = (around lshift 8)

o = (around lshift ')
p = (around lshift =)

h = (around lmet (around lalt Left))
j = (around lmet (around lalt Down))
k = (around lmet (around lalt Up))
l = (around lmet (around lalt Right))

# go to previous desktop
semicolon = (tap-hold-next-release $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Previous Desktop\"") @show_desktop_grid)
# go to next desktop
apostrophe = (tap-hold-next-release $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Next Desktop\"") @show_desktop_grid)
#+end_src
* Numeric Desktop Switching Layer
This is a layer where the numeric keys are mapped to buttons that switch to that numbered desktop.

- ~SWAP_MONITOR_WINDOWS_SCRIPT~ ::
  #+NAME: SWAP_MONITOR_WINDOWS_SCRIPT
  #+begin_src text
~/.config/kmonad/windows/swap_monitor_windows.sh
  #+end_src

#+begin_src kbdx
[numeric-desktop-switching]
[[private]]
SWAP_MONITOR_WINDOWS_SCRIPT = "|>SWAP_MONITOR_WINDOWS_SCRIPT<|"
[[keys]]
1 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 1\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 1\""))
2 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 2\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 2\""))
3 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 3\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 3\""))
4 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 4\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 4\""))
5 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 5\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 5\""))
6 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 6\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 6\""))
7 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 7\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 7\""))
8 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 8\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 8\""))
9 = (tap-hold $tap-hold-delay-min (cmd-button "$kwin_shortcut_cmd \"Switch to Desktop 9\"") (cmd-button "$kwin_shortcut_cmd \"Window to Desktop 9\""))
Minus = (cmd-button "$SWAP_MONITOR_WINDOWS_SCRIPT")
Equal = (cmd-button "$kwin_shortcut_cmd \"Window to Next Screen\"")
#+end_src
** Swap Monitors Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/windows/swap_monitor_windows.sh :mkdirp yes :tangle-mode (identity #o744)
:END:

#+begin_src sh
#!/bin/dash

# first, get the current window ID
WINDOW_ID=$(xdotool getactivewindow)

runShortcut() {
    qdbus org.kde.kglobalaccel /component/kwin invokeShortcut "$1"
}

# next, switch focus to the other monitor
runShortcut "Switch to Next Screen"

sleep 0.05

# now, move the window to the previous monitor
runShortcut "Window to Next Screen"

sleep 0.05

# finally, focus the original window and move it to the other monitor
xdotool windowfocus "$WINDOW_ID"

sleep 0.05

runShortcut "Window to Next Screen"
#+end_src
* Alphabetic Window Tiling Layer
#+begin_src kbdx
[alphabetic-window-tiling]
[[keys]]
u = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Top Left'")
i = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Top'")
o = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Top Right'")

j = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Left'")
k = (cmd-button "$kwin_shortcut_cmd 'Window Maximize'")
l = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Right'")

m = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Bottom Left'")
comma = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Bottom'")
dot = (cmd-button "$kwin_shortcut_cmd 'Window Quick Tile Bottom Right'")
#+end_src
* Desktop/Window Layer
#+begin_src kbdx
[desktop-window]
parent = { numeric-desktop-switching, alphabetic-window-tiling }
#+end_src
* Home Row Movement Layer
#+begin_src kbdx
[home-row-movement]
[[keys]]
h = 'Left'
j = 'Down'
k = 'Up'
l = 'Right'
#+end_src
* Program Paths
#+begin_src kbdx
[aliases]
ROFI = "|>ROFI<|"
DISCORD = "|>DISCORD<|"
EMACSCLIENT = "|>EMACSCLIENT<|"
#+end_src
* [[(window-switcher)][Window Switcher]]
Opens the Window Switcher

#+begin_src kbdx
[aliases]
window-switcher = (cmd-button "$ROFI -noplugins -modi window -show window -lines 5 --normal-window -matching fuzzy")
#+end_src

I compiled ~rofi~ from source and put it in ~~/.local/bin~ because the RPM version was too slow for my taste.
Some of the flags are also there for optimization reasons: ~-modi~, ~-noplugins~ and ~--normal-window~.
I noticed that the startup animation was faster with ~--normal-window~, and the other 2 flags stop ~rofi~ from doing unnecessary work.
~-matching fuzzy~ makes it use fuzzy matching instead of only matching the raw string
* [[(discord)][Discord]]
This command uses ~wmctrl~ to switch to a currently-existing Discord window, and if it fails opens a new instance of Discord.

#+begin_src kbdx
[aliases]
DISCORD_SCRIPT = "~/.config/kmonad/discord/discord.sh"
discord = (cmd-button "$DISCORD_SCRIPT")
#+end_src
** TODO Switch back to the previous window when invoked a second time
* [[(emacs)][Emacs]]
Opens Emacs: specifically an ~emacsclient~ instance.

#+begin_src kbdx
[aliases]
emacs = (cmd-button "$EMACSCLIENT --create-frame")
#+end_src
* [[(firefox)][Firefox]]
Opens a new Firefox window

- ~FIREFOX_TAB_SWITCHER_SCRIPT~ ::
  #+NAME: FIREFOX_TAB_SWITCHER_SCRIPT
  #+begin_src text
~/.config/kmonad/firefox/firefox_tab_switcher.sh
  #+end_src

#+begin_src kbdx
[aliases]
FIREFOX_TAB_SWITCHER_SCRIPT = "|>FIREFOX_TAB_SWITCHER_SCRIPT<|"

open_firefox = (cmd-button "firefox")
select_firefox_tab = (cmd-button "$FIREFOX_TAB_SWITCHER_SCRIPT")

firefox_composite = (tap-hold 135 @open_firefox @select_firefox_tab)
#+end_src

** Firefox Tab Switcher
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/firefox/firefox_tab_switcher.sh :mkdirp yes :tangle-mode (identity #o744)
:END:

#+begin_src sh
#!/bin/sh

IFS="
"

tabs=$(|>BROTAB<| list)

echo "$tabs" > /tmp/kmonadtabs

selected=$(echo "$tabs" | awk -F '\t' '{print $2}' | rofi -noplugins -dmenu -i -lines 8 --normal-window -matching fuzzy -format 'd')

selection=$(echo "$tabs" | tail -n "+$selected" | head -n 1)

activation="$(echo "$selection" | awk -F '\t' '{print $1}')"
|>BROTAB<| activate "$activation"

title="$(echo "$selection" | awk -F '\t' '{print $2}')"
wmctrl -a "$title"
#+end_src
* [[(brightness)][Brightness]]
- ~CHANGE_BRIGHTNESS_SCRIPT~ ::
  #+NAME: CHANGE_BRIGHTNESS_SCRIPT
  #+begin_src text
~/.config/kmonad/brightness/change_brightness.sh
  #+end_src
- ~QUEUE_DIGIT_SCRIPT~ ::
  #+NAME: QUEUE_DIGIT_SCRIPT
  #+begin_src text
~/.config/kmonad/brightness/queue_digit.sh
  #+end_src
- ~DIGIT_QUEUE_FILE~ ::
  #+NAME: DIGIT_QUEUE_FILE
  #+begin_src text
/tmp/kmonad_digit_queue
  #+end_src
- ~LAST_BRIGHTNESS_CHANGE_FILE~ ::
  #+NAME: LAST_BRIGHTNESS_CHANGE_FILE
  #+begin_src text
/tmp/kmonad_last_brightness_change
  #+end_src

#+begin_src kbdx
[brightness]
[[private]]
QUEUE_DIGIT_SCRIPT = "|>QUEUE_DIGIT_SCRIPT<|"
CHANGE_BRIGHTNESS_SCRIPT = "|>CHANGE_BRIGHTNESS_SCRIPT<|"

exit = (layer-rem brightness)
[[public]]
enter = (tap-hold-next-release $tap-hold-delay (layer-add brightness) (layer-toggle brightness))

up = (cmd-button "$CHANGE_BRIGHTNESS_SCRIPT +")
down = (cmd-button "$CHANGE_BRIGHTNESS_SCRIPT -")

toggle_nightlight = (cmd-button "$CHANGE_BRIGHTNESS_SCRIPT '*'")
[[keys]]
0 = (cmd-button "$QUEUE_DIGIT_SCRIPT 0")
1 = (cmd-button "$QUEUE_DIGIT_SCRIPT 1")
2 = (cmd-button "$QUEUE_DIGIT_SCRIPT 2")
3 = (cmd-button "$QUEUE_DIGIT_SCRIPT 3")
4 = (cmd-button "$QUEUE_DIGIT_SCRIPT 4")
5 = (cmd-button "$QUEUE_DIGIT_SCRIPT 5")
6 = (cmd-button "$QUEUE_DIGIT_SCRIPT 6")
7 = (cmd-button "$QUEUE_DIGIT_SCRIPT 7")
8 = (cmd-button "$QUEUE_DIGIT_SCRIPT 8")
9 = (cmd-button "$QUEUE_DIGIT_SCRIPT 9")

k = up
j = down

h = toggle_nightlight

# q displays brightness on each monitor

tab = switch_focus_composite

lmet = exit
#+end_src
** Queue Digit Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/brightness/queue_digit.sh :mkdirp yes :tangle-mode (identity #o744)
:END:
This script takes a digit and appends it to the queue of currently waiting digits. The change brightness script consumes the queue as a single integer.

Using ~dash~ shell for speed
#+begin_src sh
#!/bin/dash

FILE="|>DIGIT_QUEUE_FILE<|"
#+end_src

Verify that the argument is a number by using ~case~ and globbing.
See [[https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash/806923]](this) StackOverflow post.
#+begin_src sh
DIGIT=$1

case $DIGIT in
'' | *[!0-9]*) echo "Need to pass in a number!" >/dev/stderr; exit 1;;
*) ;;
esac
#+end_src

Next, read the current file contents, prepend it to ~DIGIT~, and then write it back.

#+begin_src sh
# read file
if [ -e "$FILE" ]; then
    CURRENT_INT=$(cat "$FILE")
fi

NEW_INT="$CURRENT_INT$DIGIT"

# also print it to stdout; helpful for debugging
echo "$NEW_INT" | tee "$FILE"
#+end_src
** Change Brightness Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/brightness/change_brightness.sh :mkdirp yes :tangle-mode (identity #o744)
:END:
#+begin_src sh
#!/bin/dash

DIGIT_FILE="|>DIGIT_QUEUE_FILE<|"
LAST_BRIGHTNESS_CHANGE_FILE="|>LAST_BRIGHTNESS_CHANGE_FILE<|"

DIRECTION=$1
#+end_src

Depending on ~DIRECTION~, set ~SIGN~ to the sign. There's a special case for ~.~; with ~.~, ~SIGN~ becomes zero and triggers special behavior further on.
#+begin_src sh

case $DIRECTION in
'+') SIGN=1 ;;
'-') SIGN=-1 ;;
'.') ;;
'*') ;;
*)
    echo "Invalid direction" >/dev/stderr
    exit 1
    ;;
esac
#+end_src

We preset ~CHANGE~ so that any code path which never sets ~CHANGE~ will use the value of ~7~.
#+begin_src sh

CHANGE=7
#+end_src

In the normal case, check if there are queued digits, and if there aren't then default to ~7~.
After reading the saved digits, clear the file's contents.
#+begin_src sh

if [ "$DIRECTION" != '.' ] && [ "$DIRECTION" != '*' ]; then
    QUEUED_DIGITS=$(cat "$DIGIT_FILE" 2>/dev/null)

    if [ -n "$QUEUED_DIGITS" ]; then
        if [ "$QUEUED_DIGITS" -ge 100 ]; then
            QUEUED_DIGITS=100
        fi

        echo "" >"$DIGIT_FILE"
        CHANGE=$QUEUED_DIGITS
    fi
#+end_src

To get the final value for ~CHANGE~, multiply ~SIGN~ by its current value.
Then, write the new value to ~LAST_BRIGHTNESS_CHANGE_FILE~.
#+begin_src sh

    CHANGE=$(echo "$SIGN * $CHANGE" | bc)
    echo "$CHANGE" >"$LAST_BRIGHTNESS_CHANGE_FILE"
#+end_src

If ~DIRECTION~ /is/ ~.~, then read ~CHANGE~ directly from ~LAST_BRIGHTNESS_CHANGE_FILE~. If it doesn't exist, then fail.
#+begin_src sh
else
    if [ "$DIRECTION" = "." ]; then
        if [ -e "$LAST_BRIGHTNESS_CHANGE_FILE" ]; then
            CHANGE=$(cat "$LAST_BRIGHTNESS_CHANGE_FILE")
        else
            echo "Last brightness change file does not yet exist!" >/dev/stderr
            exit 1
        fi
#+end_src

Otherwise, it is ~*~, which means that we want to toggle the nightlight.
In this case, we call a different script for toggling the nightlight on the actively focused monitor.
We exit the script afterwards so that we don't end up calling the standard ~changeBrightness~ script next.
#+begin_src sh
    else
        /home/sridaran/Development/Scripts/DE/toggleNightlight.sh
        exit 0
    fi
fi
#+end_src

Finally, pass ~CHANGE~ to our main ~changeBrightness~ script (not shown), which changes the brightness on the actively focused monitor.
#+begin_src sh

/home/sridaran/Development/Scripts/DE/changeBrightness.sh "$CHANGE" -n
#+end_src
* TODO [[(terminal)][Terminal]]
* [[(run)][Run]]
We use tap macros to execute the "buttons" in sequence.
To enter the run mode, we execute the ~runner~ script and then enter the ~run~ layer.
We can do this because the leader layer only lasts for one keypress.
When the run layer is added, the layer beneath it is qwerty.

#+begin_src kbdx
[run]
[[private]]
runner_script = "~/.config/kmonad/runner/runner.sh"
[[public]]
enter = #((cmd-button "$runner_script") (layer-add run))
#+end_src

To exit the run mode, we remove the ~run~ layer and then kill all instances of ~st~: the terminal we are using for the runner (and nothing else).
#+begin_src kbdx
[[private]]
exit = #((layer-rem run) (cmd-button "killall st"))
[[keys]]
lmet = exit
#+end_src
** Runner Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/runner/runner.sh :mkdirp yes :tangle-mode (identity #o744)
:END:
# :tangle-mode sets the unix file permissions for the tangled file
# we want the owner to be able to read, write and execute the file
# we are also giving read access to the group and everyone else

Using the ~dash~ shell for speed
#+begin_src sh
#!/bin/dash
#+end_src

Setting environment variables for the ~fish~ process to inherit.

- ~SKIP_FISH_GREETING~ ::
  This is a custom variable that determines whether a message should display on startup.
  I set it to 1 because I do not want it to output for the runner.
- ~STARSHIP_CONFIG~ ::
  [[https://github.com/starship/starship/][Starship]] is the shell prompt I am using.

#+begin_src sh
export SKIP_FISH_GREETING=1
export STARSHIP_CONFIG=|>STARSHIP_RUNNER_CONFIG<|
#+end_src

Sets the working directory back to home
#+begin_src sh
cd
#+end_src

- ~|>ST<|~ ::
  ~st~ is the terminal emulator
  - ~-c "..."~ ::
    This sets the X11 classnames for the window.
    My KDE config contains window rules that rounds the corners of windows with the ~rounded~ class and gives transparency and several other properties to the ~st-runner~ class
  - ~-g ...~ ::
    This sets the initial window dimensions for the terminal window.

    The format we are using is ~<width>x<height>+<xoffset>+<yoffset>~.
    I believe everything is in terms of characters, so the width represents 100 characters, and the height represents 8 lines of space.
    The offset, however, appears to be in pixels.

    See [[https://manpages.debian.org/testing/libx11-doc/XParseGeometry.3.en.html][this link]] for more details
  - ~screen~ ::
    Using ~screen~ to maintain a single shell session through each ~runner~ invocation.
    - ~-DR runner~ ::
      Attaches to a session called ~runner~, creating it if necessary.
      Some of ~screen~'s flag combinations seem a little arbitrary.
    - ~-s /bin/fish~ ::
      Tells ~screen~ to start new sessions with the ~fish~ shell.

#+begin_src sh
|>ST<| -c "rounded st-runner" -g 100x8+225+50 screen -c ~/.config/kmonad/runner/screenrc -DR runner -s /bin/fish
#+end_src

After ~st~ closes, we scroll down our runner so we no longer see the commands/output from earlier.
We do this by telling screen to send ~Control+L~ keystrokes to the ~runner~ session.
Since it's the same shell, we /will/ still be in the same working directory and have the same history as before
#+begin_src sh
screen -r runner -X stuff ""
#+end_src

The configuration we are using for ~screen~.

- ~term screen-256color~ ::
  This line fixes the colors in the ~screen~ window.
  Before, I was getting a lot of text that wasn't being highlighted.
#+begin_src text :tangle ~/.config/kmonad/runner/screenrc
term screen-256color
#+end_src
** TODO Cleanup exit command
Right now, we are doing ~killall st~, which only does what we want because we do not use ~st~ for anything else.
We should aim for a more robust solution.
** DONE Reuse the ~runner~ terminal and shell between invocations
* TODO [[(prompt)][Prompt]]
* [[(agenda)][Agenda]]
#+begin_src kbdx
[aliases]
agenda = (cmd-button "$EMACSCLIENT -ce '(org-agenda-list)'")
#+end_src
** TODO Open a floating, semi-transparent window
Instead of a fullscreen, opaque window.
** TODO Maybe switch to org-agenda
* [[(open-preset)][Open Preset]]
- ~OPEN_PRESET_SCRIPT~ ::
  #+NAME: OPEN_PRESET_SCRIPT
  #+begin_src text
~/Development/Scripts/DE/presets/rofi_menu.sh
  #+end_src

#+begin_src kbdx
[aliases]
OPEN_PRESET_SCRIPT = "~/Development/Scripts/DE/presets/rofi_menu.sh"
open-preset = (cmd-button "$OPEN_PRESET_SCRIPT")
#+end_src
* [[(org-capture)][Org Capture]]
#+begin_src kbdx
[aliases]
org-capture = (cmd-button "~/.local/bin/org-capture")
#+end_src
* [[(scroll)][Scroll]]
We set the scroll buttons to invoke the ~scroll.sh~ script once on press and once on release.
On release, the script will kill the instance created on press

- ~SCROLL_SCRIPT~ ::
  #+NAME: SCROLL_SCRIPT
  #+begin_src text
~/.config/kmonad/scroll/scroll.sh
  #+end_src
- ~SCROLL_SPEED_SCRIPT~ ::
  #+NAME: SCROLL_SPEED_SCRIPT
  #+begin_src text
~/.config/kmonad/scroll/scroll_speed.sh
  #+end_src

#+begin_src kbdx
[scroll]
[[private]]
scroll_script = "|>SCROLL_SCRIPT<|"
speed_script = "|>SCROLL_SPEED_SCRIPT<|"

left  = (cmd-button "$scroll_script h -"
                    "$scroll_script h 0")
up    = (cmd-button "$scroll_script v -"
                    "$scroll_script v 0")
down  = (cmd-button "$scroll_script v +"
                    "$scroll_script v 0")
right = (cmd-button "$scroll_script h +"
                    "$scroll_script h 0")

speed-up   = (cmd-button "$speed_script 50"
                         "$speed_script 0")
speed-down = (cmd-button "$speed_script 200"
                         "$speed_script 0")

exit = (layer-rem scroll)
[[public]]
enter = (tap-hold-next-release $tap-hold-delay (layer-add scroll) (layer-toggle scroll))
[[keys]]
h = left
l = right
k = up
j = down

caps = speed-down
lctrl = speed-down
lshift = speed-up

lmet = exit
#+end_src
** Scroll Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/scroll/scroll.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:

These are the files storing the scroll variables.
- ~SCROLL_SPEED_FILE~ ::
  #+NAME: SCROLL_SPEED_FILE
  #+begin_src text
/tmp/kmonad_scroll_script_speed
  #+end_src
- ~SCROLL_SPEED_FILE_OLD~ ::
  #+NAME: SCROLL_SPEED_FILE_OLD
  #+begin_src text
/tmp/kmonad_scroll_script_speed_old
  #+end_src
- ~SCROLL_HORIZONTAL~ ::
  #+NAME: SCROLL_HORIZONTAL
  #+begin_src text
/tmp/kmonad_scroll_script_horizontal
  #+end_src
- ~SCROLL_VERTICAL~ ::
  #+NAME: SCROLL_VERTICAL
  #+begin_src text
/tmp/kmonad_scroll_script_vertical
  #+end_src

Again using dash for speed
#+begin_src sh
#!/bin/dash
#+end_src

- ~DIRECTION~ ::
  Either ~h~ for "horizontal" or ~v~ for "vertical".
- ~MAGNITUDE~ ::
  Either ~+~ for the positive direction, ~-~ for the negative direction or ~0~ to stop
#+begin_src sh
DIRECTION="$1"
MAGNITUDE="$2"
#+end_src

Check if a process is already running for the current direction, and kill it if necessary.
We have separate PID files for horizontal and vertical scrolling because we want to be able to scroll in both directions simultaneously.
#+begin_src sh
if [ $DIRECTION = "h" ]
then
    DIRECTION_PID_FILE=|>SCROLL_HORIZONTAL<|

    if [ $MAGNITUDE = "-" ]
    then
        # if negative, then use scroll left button
        TARGET_BUTTON=6
    else
        # if positive, then use scroll right button
        TARGET_BUTTON=7
    fi
else
    DIRECTION_PID_FILE=|>SCROLL_VERTICAL<|

    if [ $MAGNITUDE = "-" ]
    then
        # if negative, then use scroll up button
        TARGET_BUTTON=4
    else
        # if positive, then use scroll down button
        TARGET_BUTTON=5
    fi
fi

if [ -e $DIRECTION_PID_FILE ]
then
    kill $(head -n1 $DIRECTION_PID_FILE)
    rm $DIRECTION_PID_FILE
#+end_src

This condition is an ~else if~ because if we are holding ~h~ and then press ~l~, we want the two to /cancel out/ rather than having the ~l~ override the ~h~.
In this code, if the direction pid file exists, we kill the process, creating a new one /only/ if we did not kill an existing one.
#+begin_src sh
elif ! [ $MAGNITUDE = "0" ]
then
#+end_src

We want this section of code in a loop, so that if the speed changes we can react to it and restart ~xdotool~ with the new speed.
#+begin_src sh
    while true
    do
#+end_src

Get the current delay from ~SCROLL_SPEED_FILE~, creating it if necessary
#+begin_src sh
        if ! [ -e |>SCROLL_SPEED_FILE<| ]
        then
            DELAY=150
            echo $DELAY > |>SCROLL_SPEED_FILE<|
        else
            DELAY=$(cat |>SCROLL_SPEED_FILE<|)
        fi
#+end_src

To emulate scrolling, we use ~xdotool~ to repeatedly send scroll button presses at a fixed interval: ~$DELAY~ milliseconds.
The ~10000~ number effectively represents "infinity", as it means that the process will only exit after ~10000 * $DELAY~ milliseconds
#+begin_src sh
        xdotool click --repeat 10000 --delay $DELAY $TARGET_BUTTON &
#+end_src

~$$~ is the PID of the shell process
#+begin_src sh
        echo "$$" > "$DIRECTION_PID_FILE"
#+end_src

Send incoming ~SIGTERM~'s to the ~xdotool~ process so that it can be killed ([[https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script][source]])
#+begin_src sh
        trap "kill $!" TERM
#+end_src

If we receive a ~USR1~ signal, restart the loop so the speed can be updated
#+begin_src sh
        trap "kill $!; wait $!; continue" USR1
#+end_src

Wait for the ~xdotool~ process to complete
#+begin_src sh
        wait $!
#+end_src

If we get to the end of the "loop" without ~USR1~ signal firing, we can safely exit
#+begin_src sh
        break
    done
fi
#+end_src
** Scroll Speed Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/scroll/scroll_speed.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:
- ~NEW_DELAY~ ::
  The new delay in milliseconds that we need ~xdotool~ to use.
  If it is equal to ~0~, then reset the delay to the old delay
#+begin_src sh
#!/bin/dash

NEW_DELAY=$1
#+end_src

Save the current speed to another file
#+begin_src sh
if [ $NEW_DELAY -ne 0 ]
then
    cat |>SCROLL_SPEED_FILE<| > |>SCROLL_SPEED_FILE_OLD<|

    # write new speed to the file
    echo $NEW_DELAY > |>SCROLL_SPEED_FILE<|
else
    cat |>SCROLL_SPEED_FILE_OLD<| > |>SCROLL_SPEED_FILE<|
fi
#+end_src

Send ~USR1~ signals to both the vertical and horizontal processes, so that they will refresh their speed
#+begin_src sh
kill -s USR1 $(cat |>SCROLL_VERTICAL<|)
kill -s USR1 $(cat |>SCROLL_HORIZONTAL<|)
#+end_src
** DONE Use ~shift~ to control scroll speed
** Original Approach
This was my original idea, but I am now implementing scrolling through a shell script
#+begin_quote
We are using keys F13-F16 to represent scrolling.
We need to do this because KMonad does not support sending mouse events.
Because these keys are not used for anything else (they aren't actually on the keyboard), we can safely remap them to buttons using ~xmodmap~, which /does/ support mouse buttons.
#+end_quote

This was in my ~~/.Xmodmap~
#+begin_src text :tangle no
keycode 191 = Left
keycode 192 = Pointer_Button5
keycode 193 = Pointer_Button4
keycode 194 = Right
#+end_src

First of all, ~xmodmap~ did not let me bind ~191~ and ~194~ to ~Pointer_Button6~ and ~Pointer_Button7~ (pushing the scroll wheel left/right), saying that it did not recognize either keysym.
As a workaround, I tried setting these to the arrow keys.

The horizontal arrow keys worked, but the up/down scrolling did not.
In most applications, the up/down arrow keys do selection in addition to scrolling, so binding ~j~ and ~k~ to arrow keys was not an acceptable solution

Scrolling works by repeatedly "clicking" the scroll buttons.
Whenever you scroll a scrollbar on your mouse, the speed at which you scroll determines how fast the scrolling occurs on your screen.

I believe the reason the vertical scrolling was not working is because KMonad was repeating the keypresses too quickly.
Because of this, it probably did not register as scrolling and was simply ignored.
* [[(volume)][Volume]]
- ~VOLUME_SCRIPT~ ::
  #+NAME: VOLUME_SCRIPT
  #+begin_src text
~/.config/kmonad/volume/volume.sh
  #+end_src
- ~VOLUME_TOGGLE_OSD_SCRIPT~ ::
  #+NAME: VOLUME_TOGGLE_OSD_SCRIPT
  #+begin_src text
~/.config/kmonad/volume/volume_popup_toggle.sh
  #+end_src
- ~VOLUME_SCRIPT_OSD_FILE~ ::
  Stores whether to show/hide volume ~osd~ popups
  #+NAME: VOLUME_SCRIPT_OSD_FILE
  #+begin_src text
/tmp/kmonad_volume_script_display_osd
  #+end_src

#+begin_src kbdx
[volume]
[[private]]
volume_script = "|>VOLUME_SCRIPT<|"
toggle_osd_script = "|>VOLUME_TOGGLE_OSD_SCRIPT<|"

up   = (cmd-button "$volume_script +"
                   "$volume_script 0")
down = (cmd-button "$volume_script -"
                   "$volume_script 0")

toggle-osd = (cmd-button "$toggle_osd_script")
mute = (cmd-button "qdbus org.kde.kglobalaccel /component/kmix invokeShortcut mute")

play-pause = 'PlayPause'

exit = (layer-rem volume)
[[public]]
enter = (tap-hold-next-release $tap-hold-delay (layer-add volume) (layer-toggle volume))
[[keys]]
k = up
j = down

m = mute
q = toggle-osd

p = play-pause

lmet = exit
#+end_src
** Volume Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/volume/volume.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:

- ~VOLUME_SCRIPT_PID_FILE~ ::
  #+NAME: VOLUME_SCRIPT_PID_FILE
  #+begin_src text
/tmp/kmonad_volume_script
  #+end_src
- ~VOLUME_HELPER_SCRIPT~ ::
  #+NAME: VOLUME_HELPER_SCRIPT
  #+begin_src text
~/.config/kmonad/volume/change_volume.py
  #+end_src

Similar to the [[Scroll Script]], this script will modulate a parameter at a given rate, writing its own PID into a file so that it can be killed when a key is released

- ~VOLUME_CHANGE_DIRECTION~ ::
  Either ~+~ to increase volume, ~-~  to decrease it or ~0~ to stop.

Like all of the other scripts, this one is POSIX-compliant
#+begin_src sh
#!/bin/dash

VOLUME_CHANGE_DIRECTION="$1"
#+end_src

Kill the instance that is currently modifying the volume (if it exists).
~kill~ will throw an error if the process is no longer alive, but that will not crash the script
#+begin_src sh
DIRECTION_PID_FILE=|>VOLUME_SCRIPT_PID_FILE<|

# Kill existing process if necessary
if [ -e $DIRECTION_PID_FILE ]; then
    kill "$(cat $DIRECTION_PID_FILE)"
    rm $DIRECTION_PID_FILE
fi
#+end_src

Only run the code if the direction is non-zero
#+begin_src sh
if ! [ "$VOLUME_CHANGE_DIRECTION" = "0" ]; then
#+end_src

Get the current volume using KMix's DBus interface.

#+begin_quote
I'm doing it this way because [[https://unix.stackexchange.com/questions/132230/read-out-pulseaudio-volume-from-commandline-i-want-pactl-get-sink-volume][this]] StackOverflow post about getting the current volume from ~pactl/pacmd~ did not yield a clean enough solution.
[[https://unix.stackexchange.com/questions/132230/read-out-pulseaudio-volume-from-commandline-i-want-pactl-get-sink-volume][This]] StackOverflow post details several solutions to get the volume from ~pacmd~, but none of them are pretty.
Unfortunately, these programs do not allow you to /get/ values cleanly, only set them.
To me, although this ~qdbus~ solution is verbose, it beats having to parse text output, which the ~pa*~ solutions all had in common.

All of the following ~qdbus~ commands are listed in this [[https://gist.github.com/srithon/3cd297bdfdd157c0a7e00ff1aeb2690c][gist]].

*NOTE*: This code caches the value of ~ACTIVE_CONTROL~ to reduce delay before the volume modulation can begin.
I found that the delay was just long enough to bother me, and a benchmark showed that everything before the ~python2~ invocation took around 60 milliseconds to run before caching.
/With/ caching, this became around 25 milliseconds
I /believe/ that this cached value will be valid so long as you do not change sound cards.
#+begin_src sh :tangle no
    ACTIVE_CONTROL_CACHE_FILE=/tmp/kmonad_volume_script_active_control

    # I'm not exactly sure what a control is
    if [ -e $ACTIVE_CONTROL_CACHE_FILE ]; then
        ACTIVE_CONTROL=$(cat $ACTIVE_CONTROL_CACHE_FILE)
    else
        ACTIVE_CONTROL=$(qdbus org.kde.kded5 /Mixers/PulseAudio__Playback_Devices_1 org.kde.KMix.Mixer.controls)
        # OPTIMIZATION: spawn in the background
        echo $ACTIVE_CONTROL > $ACTIVE_CONTROL_CACHE_FILE &
    fi
#+end_src
#+end_quote

Reads whether or not to display ~osd~ popups from the disk
#+begin_src sh
    DISPLAY_OSD_FILE=|>VOLUME_SCRIPT_OSD_FILE<|

    # I'm not exactly sure what a control is
    if [ -e $DISPLAY_OSD_FILE ]; then
        DISPLAY_OSD=$(cat $DISPLAY_OSD_FILE)
    else
        DISPLAY_OSD=1
        echo $DISPLAY_OSD > $DISPLAY_OSD_FILE &
    fi
#+end_src

#+begin_quote
#+begin_src sh :tangle no
    # Use the active control path and read the volume property from it
    CURRENT_VOLUME=$(qdbus org.kde.kded5 "$ACTIVE_CONTROL" org.kde.KMix.Control.volume)
#+end_src
#+end_quote

I had to go to the dark side and use text parsing to get the volume because when I revisited Arch Linux, I saw that the DBus interface for getting the audio control and manipulating the volume no longer existed.

I found the following command on [[https://unix.stackexchange.com/questions/89571/how-to-get-volume-level-from-the-command-line][StackOverflow]]
#+begin_src sh
    # Use amixer to get the current volume
    CURRENT_VOLUME=$(amixer get Master | grep % | awk '{print $5}' | sed -e 's/\[//' -e 's/%\]//' | head -n 1)
#+end_src

Explicitly unmute the output.
The ~&~ spawns it in the background so that we don't add extra delay before the actual volume modulation
#+begin_src sh
    pactl set-sink-mute @DEFAULT_SINK@ false &
#+end_src

Write the shell's pid to disk so the next invocation can kill it
#+begin_src sh
    echo "$$" > "$DIRECTION_PID_FILE"
#+end_src

- ~-E~​ ::
  Prevents unnecessary environment variables from being loaded (optimization).
- ~-S~ ::
  Prevents unnecessary modules from being loaded (optimization)

The reasoning behind this section being written in Python can be found under [[Volume Helper Script]]​.
In this code, the ~python2~ process inherits the PID of the shell since we are using ~exec~
#+begin_src sh
    exec python2 -ES |>VOLUME_HELPER_SCRIPT<| $CURRENT_VOLUME $VOLUME_CHANGE_DIRECTION $DISPLAY_OSD
fi
#+end_src
*** Volume Helper Script
:PROPERTIES:
:header-args:python: :tangle ~/.config/kmonad/volume/change_volume.py
:END:
The reason I wrote this section in +Lua+​~python2~ is because it requires a loop to run with a subsecond delay.
If this were written as part of the shell script, we would be calling out to ~/bin/sleep~ tens of times per second, and the interval could become visibly inconsistent.

- ~volume~ ::
  An integer representing the starting volume percentage
- ~increment~ ::
  ~+~ to increase volume, ~-~  to decrease it or ~0~ to toggle mute.
- ~display_osd~ ::
  ~1~ to display the ~osd~ popups when the volume changes, ~0~ to suppress them

#+begin_src python
from time import sleep
from os import system
from sys import argv

volume = int(argv[1])
increment = 1 if argv[2] == '+' else -1
display_osd = True if argv[3] == '1' else False
#+end_src

When we receive a ~USR1~ signal from the [[Volume OSD Toggle Script]], invert the value of ~display_osd~.
This is equivalent to reading the new value of the file; we know that the script would have inverted the value from what it was originally, so we can simply invert our variable to mirror it.
#+begin_src python
import signal

def usr1_handler(signum, frame):
    global display_osd
    display_osd = not display_osd

signal.signal(signal.SIGUSR1, usr1_handler)
#+end_src

f-strings were only introduced in python3.6, so this code uses ~string.format~.
I was originally confused by ~string.format~, thinking ~string~ was a module, but in reality ~format~ is a method defined on the ~string~ class.
#+begin_src python
while True:
    # Clamp the range of the loop between 0 and 100
    # Without these checks, there would be nothing stopping it from going out of bounds
    if volume > 100 and increment > 0 or volume < 0 and increment < 0:
        break

    volume += increment

    system('pactl set-sink-volume @DEFAULT_SINK@ {}%'.format(volume))

    if display_osd:
        system('qdbus org.kde.plasmashell /org/kde/osdService org.kde.osdService.volumeChanged {}'.format(volume))

    # 30 ms delay
    sleep(0.030)
#+end_src
This code could be further optimized by spawning the system commands with ~subprocess.Popen~, saving the handles to a list and polling/filtering them on each iteration of the loop.
The [[https://pypi.org/project/subprocess32/][subprocess32]] package is recommended when using ~subprocess~ in ~python2~, since the stock version of ~subprocess~ that ships with it has several issues.
**** Lua Implementation
I originally wrote the helper script in Lua because I thought that Python would be too slow.
However, upon further inspection of the startup time link, python2's startup time is under 3 milliseconds, which is certainly acceptable for this usecase.

I ran my own benchmarks to compare Lua's startup time without python2's and these were the results
#+begin_example
$ hyperfine 'lua -E -e ""' 'python2 -S -c ""'
Benchmark #1: lua -E -e ""
  Time (mean ± σ):       0.4 ms ±   0.2 ms    [User: 0.4 ms, System: 0.4 ms]
  Range (min … max):     0.1 ms …   2.2 ms    1214 runs

  Warning: Command took less than 5 ms to complete. Results might be inaccurate.

Benchmark #2: python2 -S -c ""
  Time (mean ± σ):       2.9 ms ±   0.5 ms    [User: 2.1 ms, System: 0.9 ms]
  Range (min … max):     2.3 ms …   5.3 ms    649 runs

  Warning: Command took less than 5 ms to complete. Results might be inaccurate.

Summary
  'lua -E -e ""' ran
    7.45 ± 4.81 times faster than 'python2 -S -c ""'
#+end_example

As mentioned earlier, Lua's startup time is many times faster,  but python2's 3 milliseconds is still an acceptable speed.
I ran my own benchmarks to compare my Lua implementation and my Python implementation (for 100 iterations of the loop) and these were the results.
#+begin_example
$ hyperfine 'lua -E change_volume.lua 0 1' 'python2 -S change_volume.py 0 1'
Benchmark #1: lua -E change_volume.lua 0 1
  Time (mean ± σ):      6.747 s ±  0.066 s    [User: 1.056 s, System: 0.913 s]
  Range (min … max):    6.685 s …  6.899 s    10 runs

Benchmark #2: python2 -S change_volume.py 0 1
  Time (mean ± σ):      6.664 s ±  0.038 s    [User: 1.060 s, System: 0.887 s]
  Range (min … max):    6.613 s …  6.730 s    10 runs

Summary
  'python2 -S change_volume.py 0 1' ran
    1.01 ± 0.01 times faster than 'lua -E change_volume.lua 0 1'
#+end_example

When taking everything into account, python2 was actually a tiny bit faster than Lua.
This difference may have just been chance, but it shows that in the grand scheme of things, Lua's superior startup time does not make a super big impact on the overall runtime.

The python2 implementation also has the advantage of not requiring any external dependencies, so it was the clear winner. Many distributions actually require python2 for their own internal packages, so it's much more likely to not have to install anything new

#+begin_quote
Replaces the running shell process with a Lua script that modulates the volume in a loop.
The reason I wrote this section in Lua is because it requires a loop to run with a subsecond delay.
If this were written as part of the shell script, we would be calling out to ~/bin/sleep~ tens of times per second, and the interval could be visibly erratic and inconsistent.
With the ~socket~ module, Lua lets you sleep without calling out to an external process.

I chose Lua over Python because Python's startup time is significantly higher (see [[https://github.com/bdrung/startup-time][this]]).
I chose it over C and other compiled languages because I didn't want to have to compile and store an executable.

*Note* that ~socket~ may not be shipped with your distribution by default.
For Fedora, I had to install the ~lua-socket~ and ~lua-socket-devel~ packages to get it working. Installing both /may/ not be necessary.

In this code, the ~lua~ process inherits the PID of the shell since we are using ~exec~
#+end_quote

#+begin_src lua :tangle no
local socket = require('socket')
local os = require('os')

local volume = tonumber(arg[1])
local increment = tonumber(arg[2])

while true do
  volume = volume + increment

  os.execute('pactl set-sink-volume @DEFAULT_SINK@ ' .. volume .. '%')
  os.execute('qdbus org.kde.plasmashell /org/kde/osdService org.kde.osdService.volumeChanged ' .. volume)

  socket.select(nil, nil, 0.04)
end
#+end_src
** Volume OSD Toggle Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/volume/volume_popup_toggle.sh :tangle-mode (identity #o744) :padline no
:END:

This script switches the contents of ~$DISPLAY_OSD_FILE~ between 0 and 1, setting the value to 0 if the file does not exist.

- ~sed~ ::
  Stream editor
  - ~-i "$DISPLAY_OSD_FILE"~ ::
    Modifies the file in-place, so we don't need to open the file once for reading and again for writing.
  - ~'y/01/10'~ ::
    From the ~sed~ man page for the ~y~ command:
    #+begin_quote
    Transliterate the characters in the pattern space which appear in source to the corresponding character in dest.
    #+end_quote
    This effectively maps ~0~ to ~1~ and ~1~ to ~0~.

#+begin_src sh
#!/bin/dash

DISPLAY_OSD_FILE=|>VOLUME_SCRIPT_OSD_FILE<|

if ! [ -e $DISPLAY_OSD_FILE ]; then
    echo "0" > "$DISPLAY_OSD_FILE"
else
    sed -i 'y/01/10/' "$DISPLAY_OSD_FILE"
fi

if [ -e |>VOLUME_SCRIPT_PID_FILE<| ]; then
    kill -s USR1 $(cat |>VOLUME_SCRIPT_PID_FILE<|)
fi
#+end_src

This is an alternate implementation of the swap using ~tr~.
See [[https://stackoverflow.com/questions/6696842/how-can-i-use-a-file-in-a-command-and-redirect-output-to-the-same-file-without-t][this]] StackOverflow post on why we can't redirect the output of ~tr~ back into the file using ~>~.
#+begin_example sh :tangle no
tr '01' '10' < $DISPLAY_OSD_FILE | sponge $DISPLAY_OSD_FILE
#+end_example
** DONE Volume layer
The volume layer would remap hjkl to control the volume.
** TODO Volume Next/Prev
Rotate to next/previous output with h/l
* [[(switch-focus)][Switch Focus]]
- ~SWITCH_MOUSE_SCREEN_SCRIPT~ ::
  #+NAME: SWITCH_MOUSE_SCREEN_SCRIPT
  #+begin_src text
/home/sridaran/Development/Scripts/DE/mouseToNextDesktop.sh
  #+end_src

#+begin_src kbdx
[aliases]
SWITCH_MOUSE_SCREEN_SCRIPT = "|>SWITCH_MOUSE_SCREEN_SCRIPT<|"

switch_mouse_screen = (cmd-button "$SWITCH_MOUSE_SCREEN_SCRIPT")
switch_focus_screen = (cmd-button "qdbus org.kde.kglobalaccel /component/kwin invokeShortcut \"Switch to Next Screen\"")

switch_focus_composite = (tap-hold 200 @switch_focus_screen @switch_mouse_screen)
#+end_src
* [[(vim)][Vim]]
- ~NVIM~ ::
  #+NAME: NVIM
  #+begin_src text
/home/sridaran/Packages/neovim/nvim0-6-0.appimage
  #+end_src
- ~NVIM_SCRIPT~ ::
  #+NAME: NVIM_SCRIPT
  #+begin_src text
/home/sridaran/.config/kmonad/vim/run_neovim.sh
  #+end_src

#+begin_src kbdx
[aliases]
NVIM_SCRIPT = "|>NVIM_SCRIPT<|"
vim = (cmd-button "kitty fish -C \"$NVIM_SCRIPT\"")
#+end_src
** Run Neovim Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/vim/run_neovim.sh :tangle-mode (identity #o744) :mkdirp yes :padline no
:END:

#+begin_src sh
#!/bin/dash

ELAPSED_TIME=$(/bin/time -f '%E' |>NEOVIM<|)
zenity --text "Ran for $ELAPSED_TIME" --notification
#+end_src
* [[(simple-datetime-overlay)][Simple Datetime Overlay]]
- Simple Datetime Overlay Path ::
  #+NAME: SIMPLE_DATETIME_OVERLAY
  #+begin_src text
/home/sridaran/.local/bin/simple-datetime-overlay
  #+end_src

This is a simple button that spawns my program and then kills all instances of it.
#+begin_src kbdx
[aliases]
SIMPLE_DATETIME_OVERLAY = "|>SDO_SCRIPT_PATH<|"
simple-datetime-overlay = (cmd-button "/bin/dash -c '$SIMPLE_DATETIME_OVERLAY'" "sleep 0.15; killall simple-datetime-overlay")
#+end_src

Here are my issues with ~simple-datetime-overlay~:
1. Setting it to show up on all monitors is ideal, but it feels too slow unless I have my CPU profile on high or max
2. *Setting it to show up on the active monitor is nice, but sometimes I don't know which monitor is active so I don't know where to look*
3. Setting it to show up on monitor 0 makes it consistently fast, but I don't want to have to turn my head to look at it

Ideally, show up on all monitors when we are on max performance, active monitor otherwise.
** Invoke Simple Datetime Overlay Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/simple-datetime-overlay/simple-datetime-overlay.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:

- SDO Script Path  ::
  #+NAME: SDO_SCRIPT_PATH
  #+begin_src text
/home/sridaran/.config/kmonad/simple-datetime-overlay/simple-datetime-overlay.sh
  #+end_src

- CPUFreq Active Profile Path ::
  #+NAME: CPUFREQ_ACTIVE_PROFILE
  #+begin_src text
/home/sridaran/.cache/set-cpufreq-profile/active-profile
  #+end_src

This script checks what my current cpu profile is, and if it is on max performance, then it displays the datetime overlay on all monitors.
Otherwise, it displays it only on the active monitor.

*TODO*: also disable pretty effects like fading on lower performance profiles
#+begin_src sh
#!/bin/dash

CURRENT_CPUFREQ_PROFILE=$(cat "|>CPUFREQ_ACTIVE_PROFILE<|")

PARAMS="--only-monitor 0"

case "$CURRENT_CPUFREQ_PROFILE" in
    "Max Performance")
        PARAMS=""
        ;;
     "High Performance")
         PARAMS="-a"
         ;;
     "Low Performance")
         PARAMS="$PARAMS --no-fade"
         ;;
     ,*)
       ;;
esac

|>SIMPLE_DATETIME_OVERLAY<| $PARAMS
#+end_src
* TODO [[(local-leader)][Local Leader]]

# Local Variables:
# org-babel-noweb-wrap-start: "|>"
# org-babel-noweb-wrap-end: "<|"
# End:
