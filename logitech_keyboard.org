#+TITLE: Logitech Keyboard Configuration

* Super Keybindings
I want to be able to use Super like a leader key when tapped.
Each headline represents a key to be pressed after tapping Super.
** Q :: Window Switcher
Launches the window switcher.
** D :: Discord
Opens Discord.
** B :: Brightness
Opens ~BrightnessControl~ GUI *OR* initiates ~BrightnessControl~ layer, where we can manipulate brightness with ~hjkl~.
Also look into [[https://github.com/maoserr/redshiftgui][redshiftgui]] to see if we can use this instead. I left it alone because building it requires a library that isn't in the Fedora repos called "[[https://sourceforge.net/projects/iup/files/3.30/Linux%20Libraries/][IUP]]".
*** BrightnessControl Layer
**** H
Rotate active monitor to the left.
**** L
Rotate active monitor to the right.
**** K
Brightness Up.
**** J
Brightness Down.
**** Esc | Super
Exit layer.
** V :: Volume
Opens volume manager.
*** Volume Layer
**** H
Rotate current output left.
**** J
Rotate current output right.
**** K
Volume up by 5.
**** L
Volume down by 5.
** T :: Terminal (Scratchpad)
Opens terminal scratchpad.
*** Hold
Opens menu with all of the available scratchpads.
*** Tap
+Opens most recently opened scratchpad+.
We can use ~yakuake~ for this basic functionality.
Instead, dedicate this to the *Terminal Layer*?.
*** Terminal Layer
**** +Super,+​] :: Next
Next terminal scratchpad (cycle).
**** +Super,+​[ :: Previous
Last terminal scratchpad (cycle).
**** L :: List
Show all open scratchpads and prompt for which one to open.
**** V :: Vim
Create a Vim scratchpad that will be deleted immediately after Vim closes.
** R :: Run
Run a single command in a small popup window.

Have it appear at the top of the screen, and have the window expand down as the output fills.

This could be super useful for things like ~remind-in 10m Do something~.
*** Layer
**** Super, Esc (in sequence)
Exit layer and close ~run~ window.
**** E
Make window taller.
*** Notes
**** Keybindings
In the spawned window, bind Ctrl+R to resize the window to the necessary length, Esc/Enter to revert the size.

After you press enter "for real", hand the scrollback buffer to ~pee resizing_program.sh less~
Might have to use kitty for this.
**** Window Properties
Source: https://www.reddit.com/r/kde/comments/d5ne9s/can_you_have_no_titlebar_and_frame_but_keep_the/
Made a window-specific override for the window class "st-runner" that disabled the title bar.
This lets us havae the nice shadow but without the title bar.
** P :: Prompt
Opens prompt to open ~rofi~ and launch custom actions by typing.
*** thyme
Opens ~rofi~ with list of ~thyme~ files.
Choose a date and then view the breakdown for that date.
*** incognito
Turns on VPN.
Disables ~thyme~.

If called a second time, disables both of these.
** A :: Agenda
Opens agenda.
** O :: Open Preset
*** Tap
Gives you preset-local shortcuts.

Automatically show help for it (this is hard to memorize).
Emacs ~which-key~ style help.
*** Hold
Opens ~rofi~ with list of available "presets".

If currently in a preset, exit the preset.
Currently loaded presets should be at the top!.
If you select a preset while another is currently active, disable the old preset.

Add support for virtual-desktop-local presets in the future.
*** Presets
**** leetcode
***** Left Monitor
1. Open fullscreen terminal.
2. ~cd ~/Development/leetcode/problems~.
***** Right Monitor
+1. Open firefox+.
+2. Navigate to [[https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU][New Year Gift - Curated List of Top 75 LeetCode Questions to Save Your Time]]+.
+3.+
0. Open firefox?.
   This would be so that when you press enter in emacs, it would open the link in the right firefox window.
1. Open ~emacs~.
2. Navigate to "problems.org".
3. Select a problem.
4. When you press enter, open the link in our firefox window and then close emacs.
***** Preset-Local Shortcuts
****** O :: Open Problem List
Opens the ~emacs~ window once again and loops from step #1.
** C :: Org-Capure
Opens org-capture.
I already have this bound to ~Super+C~, but having it on ~Super, C~ would make it easier to invoke.
** S :: Scroll
Layer that lets you emulate mouse wheel scrolling using vim keys
*** Scroll Layer
**** H
Scroll to the left
**** J
Scroll down
**** K
Scroll up
**** L
Scroll to the right
**** Shift
Increase scroll speed while held
**** Ctrl
Decrease scroll speed while held
** \ :: Local Leader Key
Use this in conjunction with presets to have local preset keybindings.
** Super :: Super
Acts as a regular press of Super (hands it to KDE).
* Layer Templates
#+PROPERTY: header-args :tangle no
** Passthrough
#+begin_example kbd
(deflayer layer-name
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _                  _
  _    _    _              _              _    _    _                    _   _
                                                                           _
  )
#+end_example
** Inclusive
#+begin_example kbd
(deflayer layer-name
  grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc
  tab  q    w    e    r    t    y    u    i    o    p    [    ]    \
  caps a    s    d    f    g    h    j    k    l    ;    '    ret
  lsft z    x    c    v    b    n    m    ,    .    /    rsft               up
  lctl lmet lalt           spc            ralt rctl                     lft rght
                                                                          down
  )
#+end_example
* Configuration
#+PROPERTY: header-args :tangle yes
#+begin_src kbd
(defcfg
  ;; For Linux
  input  (device-file "/dev/input/by-id/usb-Logitech_USB_Receiver-if02-event-kbd")
  output (uinput-sink "Logitech KMonad Output"
                       ;; To understand the importance of the following line, see the section on
                       ;; Compose-key sequences at the near-bottom of this file.
                       "/run/current-system/sw/bin/sleep 1 && /run/current-system/sw/bin/setxkbmap -option compose:ralt")
  cmp-seq rctrl    ;; Set the compose key to `RightAlt'
  cmp-seq-delay 5 ;; 5ms delay between each compose-key sequence press

  ;; Comment this is you want unhandled events not to be emitted
  fallthrough true

  ;; Set this to false to disable any command-execution in KMonad
  allow-cmd true
  )
#+end_src
* Source Layer
#+begin_src kbd
(defsrc
  grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc
  tab  q    w    e    r    t    y    u    i    o    p    [    ]    \
  caps a    s    d    f    g    h    j    k    l    ;    '    ret
  lsft z    x    c    v    b    n    m    ,    .    /    rsft               up
  lctl lmet lalt           spc            ralt rctl                     lft rght
                                                                          down
  )
#+end_src

* Default Layer
#+begin_quote
Optional: as many layers as you please

We had already defined `num` as referring to a `(layer-toggle numbers)`. We
will get into layer-manipulation soon, but first, let's just create a second
layer that overlays a numpad under our right-hand.

To easily specify layers it is highly recommended to create an empty
`deflayer` statement as a comment at the top of your config, so you can simply
copy-paste this template. There are also various empty layer templates
available in the './keymap/template' directory.
#+end_quote

Enable the "leader" layer for the next keypress.
If we release @ldr /before/ the next key, we treat the keypress as a *tap*, even if for a short period of time both keys were down.
If we release @ldr /after/ the next key, we treat it as holding.

Also, if we hold the key for more than 250 milliseconds, treat it like we are holding the key.
When we are trying to use the super key in a tap melody, we have the key down for a very short time, so having the hold timeout on 250ms lets us use it for chords more conveniently
#+begin_src kbd
(defalias
  ldr (tap-hold-next-release 250 (around-next (layer-toggle leader)) lmet)
  )
#+end_src

#+begin_src kbd
(deflayer qwerty
  grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc
  tab  q    w    e    r    t    y    u    i    o    p    [    ]    \
  lctl a    s    d    f    g    h    j    k    l    ;    '    ret
  lsft z    x    c    v    b    n    m    ,    .    /    rsft               up
  lctl @ldr lalt           spc            ralt rctl                     lft rght
                                                                          down
  )
#+end_src
* Base Leader Key Layer
When we define aliases to other aliases, they are eagerly evaluated and will throw an error if they are not defined at that point.
We solve this by plugging this code block into [[Leader Key Definitions]], which gets tangled at the very end.
#+NAME: base_leader_key_layer
#+begin_src kbd -r :tangle no
(defalias
  win @window-switcher ;; (ref:window-switcher)
  dsc @discord ;; (ref:discord)
  bri b ;; (ref:brightness)
  vol @volume ;; (ref:volume)
  trm t ;; (ref:terminal)
  run @enter-run ;; (ref:run)
  pro p ;; (ref:prompt)
  age @agenda ;; (ref:agenda)
  pre o ;; (ref:open-preset)
  cap @org-capture ;; (ref:org-capture)
  scr @enter-scroll ;; (ref:scroll)
  lld \\ ;; (ref:local-leader)
  )

(deflayer leader
  XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX   @win XX   XX   @run XX   XX   XX   XX   XX   @pro XX   XX   XX
  XX   @age @scr @dsc XX   XX   XX   XX   XX   XX   XX   XX   XX
  XX   XX   XX   @cap @vol @bri XX   XX   XX   XX   XX   XX                 XX
  XX   lmet XX             XX             XX   XX                        XX  XX
                                                                           XX
  )
#+end_src
* [[(window-switcher)][Window Switcher]]
Opens the Window Switcher

#+begin_src kbd
(defalias
  window-switcher (cmd-button "~/.local/bin/rofi -noplugins -modi window -show window -lines 5 --normal-window")
  )
#+end_src

I compiled ~rofi~ from source and put it in ~~/.local/bin~ because the RPM version was too slow for my taste.
Some of the flags are also there for optimization reasons: ~-modi~, ~-noplugins~ and ~--normal-window~.
I noticed that the startup animation was faster with ~--normal-window~, and the other 2 flags stop ~rofi~ from doing unnecessary work.
* [[(discord)][Discord]]
This command uses ~wmctrl~ to switch to a currently-existing Discord window, and if it fails opens a new instance of Discord.

#+begin_src kbd
(defalias
  discord (cmd-button "wmctrl -a discord || /usr/bin/Discord")
  )
#+end_src
** TODO Switch back to the previous window when invoked a second time
* TODO [[(brightness)][Brightness]]
* [[(volume)][Volume]]
#+begin_src kbd
(defalias
  volume (cmd-button "/usr/bin/pavucontrol")
  )
#+end_src
** TODO Volume layer
The volume layer would remap hjkl to control the volume.
* TODO [[(terminal)][Terminal]]
* [[(run)][Run]]
We use tap macros to execute the "buttons" in sequence.
To enter the run mode, we execute the ~runner~ script and then enter the ~run~ layer.
We can do this because the leader layer only lasts for one keypress.
When the run layer is added, the layer beneath it is qwerty.

To exit the run mode, we remove the ~run~ layer and then kill all instances of ~st~: the terminal we are using for the runner (and nothing else).
#+begin_src kbd
(defalias
  enter-run #((cmd-button "~/.config/kmonad/runner/runner.sh") (layer-add run))
  exit-run #((layer-rem run) (cmd-button "killall st"))
  )
#+end_src

We named it like this to avoid conflicts with other aliases.
#+begin_src kbd
(defalias
  r_e @exit-run ;; exit run layer; stands for run_exit
  )

(deflayer run
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _                  _
  _    @r_e _              _              _    _                         _   _
                                                                           _
  )
#+end_src
** Runner Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/runner/runner.sh :mkdirp yes :tangle-mode (identity #o744)
:END:
# :tangle-mode sets the unix file permissions for the tangled file
# we want the owner to be able to read, write and execute the file
# we are also giving read access to the group and everyone else

Using the ~dash~ shell for speed
#+begin_src sh
#!/bin/dash
#+end_src

Setting environment variables for the ~fish~ process to inherit.

- ~SKIP_FISH_GREETING~ ::
  This is a custom variable that determines whether a message should display on startup.
  I set it to 1 because I do not want it to output for the runner.
- ~STARSHIP_CONFIG~ ::
  [[https://github.com/starship/starship/][Starship]] is the shell prompt I am using.
  I want the runner to have a different configuration than my normal shell, so this points to the other config

#+begin_src sh
export SKIP_FISH_GREETING=1
export STARSHIP_CONFIG=~/.config/starship_runner.toml
#+end_src

Sets the working directory back to home
#+begin_src sh
cd
#+end_src

- ~~/.local/bin/st~ ::
  ~st~ is the terminal emulator
  - ~-c "..."~ ::
    This sets the X11 classnames for the window.
    My KDE config contains window rules that rounds the corners of windows with the ~rounded~ class and gives transparency and several other properties to the ~st-runner~ class
  - ~-g ...~ ::
    This sets the initial window dimensions for the terminal window.

    The format we are using is ~<width>x<height>+<xoffset>+<yoffset>~.
    I believe everything is in terms of characters, so the width represents 100 characters, and the height represents 8 lines of space.
    The offset, however, appears to be in pixels.

    See [[https://manpages.debian.org/testing/libx11-doc/XParseGeometry.3.en.html][this link]] for more details
  - ~screen~ ::
    Using ~screen~ to maintain a single shell session through each ~runner~ invocation.
    - ~-DR runner~ ::
      Attaches to a session called ~runner~, creating it if necessary.
      Some of ~screen~'s flag combinations seem a little arbitrary.
    - ~-s /bin/fish~ ::
      Tells ~screen~ to start new sessions with the ~fish~ shell.

#+begin_src sh
~/.local/bin/st -c "rounded st-runner" -g 100x8+225+50 screen -c ~/.config/kmonad/runner/screenrc -DR runner -s /bin/fish
#+end_src

After ~st~ closes, we scroll down our runner so we no longer see the commands/output from earlier.
We do this by telling screen to send ~Control+L~ keystrokes to the ~runner~ session.
Since it's the same shell, we /will/ still be in the same working directory and have the same history as before
#+begin_src sh
screen -r runner -X stuff ""
#+end_src

The configuration we are using for ~screen~.

- ~term screen-256color~ ::
  This line fixes the colors in the ~screen~ window.
  Before, I was getting a lot of text that wasn't being highlighted.
#+begin_src text :tangle ~/.config/kmonad/runner/screenrc
term screen-256color
#+end_src
** TODO Cleanup exit command
Right now, we are doing ~killall st~, which only does what we want because we do not use ~st~ for anything else.
We should aim for a more robust solution.
** DONE Reuse the ~runner~ terminal and shell between invocations
* TODO [[(prompt)][Prompt]]
* [[(agenda)][Agenda]]
#+begin_src kbd
(defalias
  agenda (cmd-button "kitty ~/.local/bin/taskwarrior-tui")
  )
#+end_src
** TODO Open a floating, semi-transparent window
Instead of a fullscreen, opaque window.
** TODO Maybe switch to org-agenda
* TODO [[(open-preset)][Open Preset]]
* [[(org-capture)][Org Capture]]
#+begin_src kbd
(defalias
  org-capture (cmd-button "~/.local/bin/org-capture"))
#+end_src
* [[(scroll)][Scroll]]
We set the scroll buttons to invoke the ~scroll.sh~ script once on press and once on release.
On release, the script will kill the instance created on press
#+begin_src kbd
(defalias
  enter-scroll (layer-add scroll)
  exit-scroll (layer-rem scroll)

  scroll-left  (cmd-button "~/.config/kmonad/scroll/scroll.sh h -"
                           "~/.config/kmonad/scroll/scroll.sh h 0")
  scroll-up    (cmd-button "~/.config/kmonad/scroll/scroll.sh v -"
                           "~/.config/kmonad/scroll/scroll.sh v 0")
  scroll-down  (cmd-button "~/.config/kmonad/scroll/scroll.sh v +"
                           "~/.config/kmonad/scroll/scroll.sh v 0")
  scroll-right (cmd-button "~/.config/kmonad/scroll/scroll.sh h +"
                           "~/.config/kmonad/scroll/scroll.sh h 0")

  scroll-speed-up   (cmd-button "~/.config/kmonad/scroll/scroll_speed.sh 50"
                              "~/.config/kmonad/scroll/scroll_speed.sh 0")
  scroll-speed-down (cmd-button "~/.config/kmonad/scroll/scroll_speed.sh 200"
                                "~/.config/kmonad/scroll/scroll_speed.sh 0")
  )
#+end_src

#+begin_src kbd
(defalias
  s_h @scroll-left
  s_l @scroll-right
  s_k @scroll-up
  s_j @scroll-down

  s_u @scroll-speed-up
  s_d @scroll-speed-down

  s_e @exit-scroll)

(deflayer scroll
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  _    _    _    _    _    _    _    _    _    _    _    _    _    _
  @s_d _    _    _    _    _    @s_h @s_j @s_k @s_l _    _    _
  @s_u _    _    _    _    _    _    _    _    _    _    _                  _
  @s_d @s_e _              _              _    _                         _   _
                                                                           _
  )
#+end_src
** Scroll Script
:PROPERTIES:
:header-args:sh:  :tangle ~/.config/kmonad/scroll/scroll.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:

Again using dash for speed
#+begin_src sh
#!/bin/dash
#+end_src

- ~DIRECTION~ ::
  Either ~h~ for "horizontal" or ~v~ for "vertical".
- ~MAGNITUDE~ ::
  Either ~+~ for the positive direction, ~-~ for the negative direction or ~0~ to stop
#+begin_src sh
DIRECTION="$1"
MAGNITUDE="$2"
#+end_src

Files storing the scroll speeds
#+begin_src sh
SCROLL_SPEED_FILE=/tmp/kmonad_scroll_script_speed
SCROLL_SPEED_FILE_OLD=/tmp/kmonad_scroll_script_speed_old
#+end_src

Check if a process is already running for the current direction, and kill it if necessary.
We have separate PID files for horizontal and vertical scrolling because we want to be able to scroll in both directions simultaneously.
#+begin_src sh
if [ $DIRECTION = "h" ]
then
    DIRECTION_PID_FILE=/tmp/kmonad_scroll_script_horizontal

    if [ $MAGNITUDE = "-" ]
    then
        # if negative, then use scroll left button
        TARGET_BUTTON=6
    else
        # if positive, then use scroll right button
        TARGET_BUTTON=7
    fi
else
    DIRECTION_PID_FILE=/tmp/kmonad_scroll_script_vertical

    if [ $MAGNITUDE = "-" ]
    then
        # if negative, then use scroll up button
        TARGET_BUTTON=4
    else
        # if positive, then use scroll down button
        TARGET_BUTTON=5
    fi
fi

if [ -e $DIRECTION_PID_FILE ]
then
    kill $(head -n1 $DIRECTION_PID_FILE)
    rm $DIRECTION_PID_FILE
#+end_src

This condition is an ~else if~ because if we are holding ~h~ and then press ~l~, we want the two to /cancel out/ rather than having the ~l~ override the ~h~.
In this code, if the direction pid file exists, we kill the process, creating a new one /only/ if we did not kill an existing one.
#+begin_src sh
elif ! [ $MAGNITUDE = "0" ]
then
#+end_src

We want this section of code in a loop, so that if the speed changes we can react to it and restart ~xdotool~ with the new speed.
#+begin_src sh
    while true
    do
#+end_src

Get the current delay from ~$SCROLL_SPEED_FILE~, creating it if necessary
#+begin_src sh
        if ! [ -e $SCROLL_SPEED_FILE ]
        then
            DELAY=150
            echo $DELAY > $SCROLL_SPEED_FILE
        else
            DELAY=$(cat $SCROLL_SPEED_FILE)
        fi
#+end_src

To emulate scrolling, we use ~xdotool~ to repeatedly send scroll button presses at a fixed interval: ~$DELAY~ milliseconds.
The ~10000~ number effectively represents "infinity", as it means that the process will only exit after ~10000 * $DELAY~ milliseconds
#+begin_src sh
        xdotool click --repeat 10000 --delay $DELAY $TARGET_BUTTON &
#+end_src

~$$~ is the PID of the shell process
#+begin_src sh
        echo "$$" > "$DIRECTION_PID_FILE"
#+end_src

Send incoming ~SIGTERM~'s to the ~xdotool~ process so that it can be killed ([[https://linuxconfig.org/how-to-propagate-a-signal-to-child-processes-from-a-bash-script][source]])
#+begin_src sh
        trap "kill $!" TERM
#+end_src

If we receive a ~USR1~ signal, restart the loop so the speed can be updated
#+begin_src sh
        trap "kill $!; wait $!; continue" USR1
#+end_src

Wait for the ~xdotool~ process to complete
#+begin_src sh
        wait $!
#+end_src

If we get to the end of the "loop" without ~USR1~ signal firing, we can safely exit
#+begin_src sh
        break
    done
fi
#+end_src
** Scroll Speed Script
:PROPERTIES:
:header-args:sh: :tangle ~/.config/kmonad/scroll/scroll_speed.sh :mkdirp yes :tangle-mode (identity #o744) :padline no
:END:
- ~NEW_DELAY~ ::
  The new delay in milliseconds that we need ~xdotool~ to use.
  If it is equal to ~0~, then reset the delay to the old delay
#+begin_src sh
#!/bin/dash

NEW_DELAY=$1
#+end_src

Files storing the scroll speeds
#+begin_src sh
SCROLL_SPEED_FILE=/tmp/kmonad_scroll_script_speed
SCROLL_SPEED_FILE_OLD=/tmp/kmonad_scroll_script_speed_old
#+end_src

Save the current speed to another file
#+begin_src sh
if [ $NEW_DELAY -ne 0 ]
then
    cat /tmp/kmonad_scroll_script_speed > /tmp/kmonad_scroll_script_speed_old

    # write new speed to the file
    echo $NEW_DELAY > /tmp/kmonad_scroll_script_speed
else
    cat /tmp/kmonad_scroll_script_speed_old > /tmp/kmonad_scroll_script_speed
fi
#+end_src

Send ~USR1~ signals to both the vertical and horizontal processes, so that they will refresh their speed
#+begin_src sh
kill -s USR1 $(cat /tmp/kmonad_scroll_script_vertical)
kill -s USR1 $(cat /tmp/kmonad_scroll_script_horizontal)
#+end_src
** DONE Use ~shift~ to control scroll speed
** Original Approach
This was my original idea, but I am now implementing scrolling through a shell script
#+begin_quote
We are using keys F13-F16 to represent scrolling.
We need to do this because KMonad does not support sending mouse events.
Because these keys are not used for anything else (they aren't actually on the keyboard), we can safely remap them to buttons using ~xmodmap~, which /does/ support mouse buttons.
#+end_quote

This was in my ~~/.Xmodmap~
#+begin_src text :tangle no
keycode 191 = Left
keycode 192 = Pointer_Button5
keycode 193 = Pointer_Button4
keycode 194 = Right
#+end_src

First of all, ~xmodmap~ did not let me bind ~191~ and ~194~ to ~Pointer_Button6~ and ~Pointer_Button7~ (pushing the scroll wheel left/right), saying that it did not recognize either keysym.
As a workaround, I tried setting these to the arrow keys.

The horizontal arrow keys worked, but the up/down scrolling did not.
In most applications, the up/down arrow keys do selection in addition to scrolling, so binding ~j~ and ~k~ to arrow keys was not an acceptable solution

Scrolling works by repeatedly "clicking" the scroll buttons.
Whenever you scroll a scrollbar on your mouse, the speed at which you scroll determines how fast the scrolling occurs on your screen.

I believe the reason the vertical scrolling was not working is because KMonad was repeating the keypresses too quickly.
Because of this, it probably did not register as scrolling and was simply ignored.
* TODO [[(local-leader)][Local Leader]]

* Leader Key Definitions
We need to do this in order to get the layer aliases to evaluate /after/ all of the helper aliases are defined.
Otherwise, we get an error saying that the aliases are non-existent.
#+begin_src kbd :noweb strip-export
<<base_leader_key_layer>>
#+end_src
